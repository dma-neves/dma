<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<title>DMA</title>
	<link rel="stylesheet" href="styles/main.css" type = "text/css">
    <link href="https://fonts.googleapis.com/css?family=Montserrat&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

    <script src="scripts/main.js"></script>

</head>

<body>

    <div class="content">
        
        <h1>DCPU - From Logic Gates to a Functioning Processor</h1>
        <p>Aug 27, 2023</p>

        <h2>Index</h2>

        <ul>
            <li><a href="#introduction">1. Introduction</a></li>
            <li><a href="#background">2. Background</a></li>
            <li><a href="#alu">3. Buliding an ALU</a></li>
            <li><a href="#state">4. State, Memory and Clock</a></li>
            <li><a href="#isa">5. Instruction Set Architecture</a></li>
            <li><a href="#cu">6. Control Unit</a></li>
            <li><a href="#firstprogram">7. Executing a Program</a></li>
            <li><a href="#assembler">8. Assembler</a></li>
            <li><a href="#fpga">9. FPGA</a></li>


        </ul>

        <h2 id="introduction">1. Introduction</h2>

        <figure>
            <img src="resources/eniac.jpg" width="500">
            <figcaption>Fig.1 ENIAC 1946 (First Programmable Digital Computer)</figcaption>
        </figure>

        <p>
            Since a long time, I've wondered how (the seemingly magical) computers worked. My first attempts at understanding these 
            complicated machines arose during middle school while playing around with redstone in Minecraft and building simple circuits. But it's
            fair to say, the jump from some simulated wiring in a video game to a functional computer was a bit ambitious. Fast forward 
            to my second year of University, and after learning about Digital Systems, Computer Architectures and Operating Systems, I 
            felt I finally had the necessary base knowledge to make the leap. With some basic knowledge of VHDL I decided to design and implement
            a simple ALU, and then went from there.
        </p>
            In this guide, I will try to guide you through the steps I went through (excluding all the original trial and error) to
            build a primitive CPU using logic gates as the foundational building blocks. Even though VHDL allows one to design and implement complex systems
            using high-level behavioral descriptions (that are then compiled down to logic gates), I tried to purposely avoid these features (like processes)
            in order to achieve a deeper and more complete understanding of the inner workings of a CPU.
        <p>

        <p>
            It's important to note that the CPU we will be bulding is in no way revolutionary, impressive or particularly well designed. Hence the
            the name DCPU (Dumb CPU). Rather, the CPU is supposed to be as simple as possible, while still including most of the important functionalities
            a CPU needs to be usable.
        </p>

        <p>
            <b>Note:</b> The source code of this project can be found in my Github <a href="https://github.com/dma-neves/dcpu/">repository<a>. Also note that the original
                project is a 16 bit CPU, while the code I provide in this document follows mostly an 8 bit design for compactness.
        </p>

        <h2 id="background">2. Background</h2>

        <!--

            Basic CPU, von neuman architecture
            Logic gates
            VHDL, FPGA
            Tools: ghdl, altera
        -->

        <p>
            Before diving into the implemention, we first need to establish some basic background information and concepts like the Von Nuemann Architecture,
            transistors, logic gates, binary number representation, Hardware Description Languages and FPGAs. If you are already familiar with these concepts, skip to the next chapter.
        </p>

        <figure>
            <img src="resources/vonneuman.jpg" width="500">
            <figcaption>Fig.2 Von Neuman Architecture</figcaption>
        </figure>

        <p>
            In 1945, John Von Neumann proposed an architecture for an electronic digital computer (Fig.2). This would endup becoming the basis for all computer architectures,
            even to this day. The architecture proposes a system with the following essential components:
            <ul>
                <li>A CPU (Central Processing Unit) with an ALU (Arithmetic Logic Unit) and registers. A register stores a value in a set of bits.</li>
                <li>A control unit including an instruction register and a program counter.</li>
                <li>A memory unit that stores data and instructions.</li>
                <li>Input and output mechanisms.</li>
            </ul>

            Our CPU will mostly follow this norm, with some small deviations. We will seperate the memory unit in a read-only unit that stores instructions and 
            a read-write unit to store and manipulate data. This decision is a bit redundant, but makes our lives slightly easier. We will also mostly ignore IO.
        </p>

        <figure>
            <img src="resources/logicgates.png" width="500">
            <figcaption>Fig.3 Logic Gates</figcaption>
        </figure>

        <p>
            Fundametally, computers are made of billions of <a href="https://en.wikipedia.org/wiki/Transistor">transistors</a>. These transistors are combined to form logic gates. With logic gates we can build any 
            digital system, including our CPU. A logic gate takes one or two bits as input and outputs a single bit. Fig.3 shows all the basic logic gates. AND outputs
            1 if both inputs are 1 otherwise 0, OR outputs 1 if any of the inputs is 1 and XOR outputs 1 if exactly one of the inputs is 1. The bottom three logic gates
            are the same as the first three but followed by a NOT logic gate. A NOT logic gates that takes a single input and outputs its negation. We can combine
            these logic gates to add two numbers represented in binary form, perform more complex arithmetic operations, store data and even implement a modern Intel or AMD CPU if we were clever enough.
        </p>

        <!-- <p>
            Given that computers are built entirely from logic gates that only operate over bits, all numbers (and values in general) must be represented in binary
            form. Just like we ususually represent numbers using combinations of 10 digits (0, 1, 2, ..., 9), in binary we represent numbers using combinations of just 2 digits (0 and 1).
            The numbers from 0 to 5 are represented in binary as follows: 0, 1, 10, 11, 100, 101. From here on out, whenever we want to express numbers written in base-2, we
            will use the prefix '0b' to easily differentiate from the base-10 notation. For example the previous numbers from 0 to 5 can be expressed as follows:
            0b0, 0b1, 0b10, 0b11, 0b100, 0b101.
        </p> -->

        <p>
             In order to develop our own CPU, we need to somehow create or represent a circtuit composed of these logic gates. One way would be to buy some chips with
             logic gates and assemble them on a breadboard. Another option would be to design an manufacture an actual microchip. Given that both these
             options don't scale very well, can cost some money and aren't very debug friendly, a more convenient and cheaper alternative is to design our circuits
             using a harware description language like VHDL. These languages allow one to describe a digital system using code. With the VHDL code we can then simulate
             the circuit on our computer, or "upload" it to an FPGA (Field Programmable Gate Array). An FPGA is a integrated circuit that can be configured to behave
             as "any" circuit we want. 
        </p>
            Note that this guide will not include an in depth tutorial on VHDL, so even though the VHDL we'll be writing 
            is very basic, you might want to watch some basic VHDL tutorial first. I will also assume that you have some basic knowledge of programming and concepts
            like <a href="https://www.geeksforgeeks.org/stack-data-structure/">stacks</a>, 
            <a href="https://www.geeksforgeeks.org/c-pointers/">pointers</a>, 
            <a href="https://www.geeksforgeeks.org/binary-representations-in-digital-logic/">binary representation</a>, 
            <a href="https://www.geeksforgeeks.org/bitwise-operators-in-c-cpp/">bit manipulation</a>,
            etc.
            In terms of tools, I personally used <a href="https://ghdl.github.io/ghdl/">ghdl</a>
            to simulate VHDL on my computer
            and used the <a href="https://www.intel.com/content/www/us/en/software-kit/666221/intel-quartus-ii-web-edition-design-software-version-13-1-for-windows.html">Intel Quartus II</a> 
            software to program my ALTERA FPGA CycloneII EP2C5T144.
        <p>

        </p>

        <h2 id="alu">3. Building an ALU</h2>

        <!--
            Logic Gates - vhdl
            Logical operations
            Adder
            Full Adder
            ALU
        -->

        <figure>
            <img src="resources/alu.png" width="400">
            <figcaption>Fig.4 Arithmetic Logic Unit</figcaption>
        </figure>        

        <p>
            Our first step is to build an ALU (Arithmetic Logic Unit). This unit is responisble for carrying out all the math operations a CPU might need to perfrom. 
            A simple ALU (Fig.4), takes as inputs two binary numbers (operands) and an operation code (opcode), and outputs a binary number (result) and some flags (status) that correspond to the
            result of performing the specified operation on the input numbers.
        </p>

        <figure>
            <img src="resources/half-adder.svg" width="250">
            <figcaption>Fig.5 Half-Adder</figcaption>
        </figure>                

        <figure>
            <img src="resources/full-adder.svg" width="500">
            <figcaption>Fig.6 Full-Adder</figcaption>
        </figure>               

        <p>
            The first operation we'll implement is addition. If we want to add two bits A and B, we can use the circuit seen in Fig.5, a half-adder. The AND gate
            computes the carry bit and the XOR gate the result bit. If A and B are 1 then the result is 0 and the carry is 1. If A and B are 0 then the result is 0 and the carry is 0.
            If only A or only B is 1, the result is 1 and the carry 0. To make a full-adder (Fig.6) that takes as input two bits A and B, and a carry bit Cin, we simply chain two
            half-adders and OR the carry bits. We can implement this circuit in VHDL as follows:
        </p>

        <pre>
            <code>
    entity FullAdder is

    Port(
        carryIn : IN STD_LOGIC;
        a : IN STD_LOGIC;
        b : IN STD_LOGIC;
        
        result : OUT STD_LOGIC;
        carryOut : OUT STD_LOGIC
    );

    end FullAdder;

    architecture Behavioral of FullAdder is

    signal result_0, carry_0, carry_1 : STD_LOGIC;

    begin
    result_0 <= a xor b;
    carry_0 <= a and b;
    carry_1 <= result_0 and carryIn;
    result <= result_0 xor carryIn;
    carryOut <= carry_0 or carry_1;
    end Behavioral;
            </code>
        </pre>

        <p>
            To make an adder that adds two numbers A and B of N bits, we can use N full-adders. We add the first bits from A and B using 
            the first full-adder, passing 0 as the carry in, then add the second bits from A and B using the second full-adder, routing the carry out from the first full-adder to
            the carry in from the second full-adder, and so on. The following code implements an 8 bit adder:
        </p>

        <pre>
            <code>
    entity Adder is
    Port(
        a : IN STD_LOGIC_VECTOR(7 downto 0);
        b : IN STD_LOGIC_VECTOR(7 downto 0);
        
        result : OUT STD_LOGIC_VECTOR(7 downto 0);
        carryOut : OUT STD_LOGIC
    );
    end Adder;
    
    architecture Behavioral of Adder is
    // Components code here
    signal co_0, co_1, co_2, co_3, co_4, co_5, co_6, co_7 : STD_LOGIC;
    
    begin
    S0 : FullAdder port map ('0', a(0), b(0), result(0), co_0);
    S1 : FullAdder port map (co_0, a(1), b(1), result(1), co_1);
    S2 : FullAdder port map (co_1, a(2), b(2), result(2), co_2);
    S3 : FullAdder port map (co_2, a(3), b(3), result(3), co_3);
    S4 : FullAdder port map (co_3, a(4), b(4), result(4), co_4);
    S5 : FullAdder port map (co_4, a(5), b(5), result(5), co_5);
    S6 : FullAdder port map (co_5, a(6), b(6), result(6), co_6);
    S7 : FullAdder port map (co_6, a(7), b(7), result(7), co_7);
    carryOut <= co_7;
    end Behavioral;                
            </code>
        </pre>

        <p>
            Logic operations on N bit numbers are easily implemented by performing the operation (like AND, OR, NOT, etc) on all the N inputs.
            Since they are logic operations, they are directly implemented by a single logic gate. For example an AND operation between two 8 bit numbers
            can be implemented as follows:
        </p>

        <pre>
            <code>
    entity And_8 is
    Port(
        a : in STD_LOGIC_VECTOR(7 downto 0);
        b : in STD_LOGIC_VECTOR(7 downto 0);
        
        a_and_b : out STD_LOGIC_VECTOR(7 downto 0)
    );
    end And_8;
    
    architecture Behavioral of And_8 is
    
    begin
    a_and_b(0) <= a(0) and b(0);
    a_and_b(1) <= a(1) and b(1);
    a_and_b(2) <= a(2) and b(2);
    a_and_b(3) <= a(3) and b(3);
    a_and_b(4) <= a(4) and b(4);
    a_and_b(5) <= a(5) and b(5);
    a_and_b(6) <= a(6) and b(6);
    a_and_b(7) <= a(7) and b(7);
    end Behavioral;
            </code>
        </pre>
        
        <p>
            The next challange is dealing with subtractions and negative numbers. The most popular approach to this problem
            is using the <a href="https://en.wikipedia.org/wiki/Two%27s_complement">two's compliment</a> method. In order to be able to represent both
            posisitive and negative values, we assume that the the binary digit with the greatest place value represents the number's sign. 0 corresponds
            to a positive number and 1 corresponds to a negative number. Positive numbers are represented in the same way as before, while negative numbers 
            are encoded diffirently. To represent a negative numbre in two's compliment, we use the following method:
            <ul>
                <li>Starting with the equivalent positive number.</li>
                <li>Invert (or flip) all bits.</li>
                <li>Add 1 to the entire inverted number, ignoring any overflow<,/li>
            </ul>
            This encoding might seem a bit odd, but it actually allows for some nice properties. Namely, adding two numbers in this representation works perfectly
            with both negative and positive numbers. For example adding 4 (0b00000100) to -3 (0b11111101), this is 4-3, gives us 0b11111111, which encodes the value -1.
            By adding a module to our ALU that negates a value, we can then implement subtractions by performing negations followed by additions. This is A-B is the same
            can be implemented as A+(-B). A negation module can be implement as follows using the previous adder and an 8 bit NOT operator:
        </p>

        <pre>
            <code>
    entity Negate is
    Port(
        a : in STD_LOGIC_VECTOR(8 downto 0);
        neg_a : out STD_LOGIC_VECTOR(8 downto 0);
        overflow : out STD_LOGIC
    );
    end Negate;
    
    architecture Behavioral of Negate is
    
    // Components code here
    signal not_a : STD_LOGIC_VECTOR(8 downto 0);
    
    begin
    N: Not_8 port map(a, not_a);
    S: Adder port map(not_a, "00000001", neg_a, overflow);
    end Behavioral;           
            </code>
        </pre>


        <figure>
            <img src="resources/multiplexer.svg" width="300">
            <figcaption>Fig.7 Multiplexer</figcaption>
        </figure>  

        <p>
            The final piece we need to build the ALU is a multiplexer. A multiplexer is a component that receives a set of inputs I0, I1, ..., IN
            (each input can be a single bit or binary values) and a selector S, and outputs the value In, where n is the index selected by S. This is,
            if S is 0b0 the output is I0, if S is 0b1 the output is I1, if S is 0b10 the output is I2 and so on. Such a component can be easily implemented
            using AND gates connecting each input I with the necessary S value (NOT gates used for the bits that should be zero) and a final OR gate
            combining all the intermediate outputs. Fig.7 shows a multiplexer circuit with 4 input values and a two bit selector S. Note that in such a diagram a
            circle preciding a gate's input represents that the input is flipped (NOT gate). This multiplexer can be implemented as follows:
        </p>

        <pre>
            <code>
    entity Mux4 is
    Port(
        I0, I1, I2, I3 : in STD_LOGIC_VECTOR(8 downto 0);
        sel : in STD_LOGIC_VECTOR(1 downto 0);
        o : out STD_LOGIC_VECTOR(8 downto 0)
    );
    end Mux4;
    
    architecture Behavioral of Mux4 is
    signal I0_s, I1_s, I2_s, I3_s : STD_LOGIC_VECTOR(8 downto 0);
    begin
    
    I0_s(0) <= I0(0) and (not sel(0)) and (not sel(1));
    //I0_s(...) <= ...
    I0_s(8) <= I0(8) and (not sel(0)) and (not sel(1));
    
    I1_s(0) <= I1(0) and (not sel(0)) and sel(1);
    //I1_s(...) <= ...
    I1_s(8) <= I1(8) and (not sel(0)) and sel(1);
    
    I2_s(0) <= I2(0) and sel(0)) and (not sel(1));
    //I2_s(...) <= ...
    I2_s(8) <= I2(8) and sel(0)) and (not sel(1));
    
    I3_s(0) <= I3(0) and sel(0)) and sel(1);
    //I3_s(...) <= ...
    I3_s(8) <= I3(8) and sel(0)) and sel(1);
    
    end Behavioral;                
            </code>
        </pre>

        <p>
            With an adder, logic operators, a negator and some multiplexers, we can finally build our ALU. Lets consider that the ALU will support 8 different
            operations. Our opcode will therefore be specified by a 3 bit value (since 2^3 = 8). Tab.1 shows the 8 operations.
        </p>

        <figure>
            <table border="1">

                <thead>
                    <tr>
                        <th>Opcode</th>
                        <th>Name</th>
                        <th>Description</th>
                    </tr>
                </thead>

                <tbody>
                    <tr>
                        <td>000</td>
                        <td>add</td>
                        <td>A + B</td>
                    </tr>
                    <tr>
                        <td>001</td>
                        <td>sub</td>
                        <td>A - B</td>
                    </tr>
                    <tr>
                        <td>010</td>
                        <td>inc</td>
                        <td>A + 1</td>
                    </tr>
                    <tr>
                        <td>011</td>
                        <td>dec</td>
                        <td>A - 1</td>
                    </tr>
                    <tr>
                        <td>100</td>
                        <td>neg</td>
                        <td>-A</td>
                    </tr>
                    <tr>
                        <td>101</td>
                        <td>not</td>
                        <td>~A</td>
                    </tr>
                    <tr>
                        <td>110</td>
                        <td>and</td>
                        <td>A ^ B</td>
                    </tr>
                    <tr>
                        <td>111</td>
                        <td>or</td>
                        <td>A v B</td>
                    </tr>
                </tbody>
            </table>
            <figcaption>Tab.1 ALU opcodes</figcaption>
        </figure>
        
        <p>
            Fig.8 shows a diagram of the ALU that implements these 8 operations. It receives two 8 bit input operands A and B as well as an input opcode. For
            output, we have a single 8 bit result and three flags: overflow, negative and zero.
            The ALU contains the Adder, Negate, NOT, OR and AND components we
            discussed earlier, a set of multiplexers and some auxiliary gates. The first operand of the Adder is always A, while the second is selected by a multiplexer
            that can either select B (add), 1 (inc), -1 (dec) or the result of the Negate component (sub). The Negate input is selected by a multiplexer that can either
            select A (neg) or B (sub). All the other components simply operate over A and B (operations: not, and, or). The final result is selected by a multiplexer
            that can either select the Negate output (neg), the NOT output (not), the AND output (and), the OR output (or) or the Adder output (operations: add, inc, dec, sub).
            The overflow flag can be set either by the Adder component or the Negate component, and the negative and zero flag simply check if the result is negative or
            zero.
        </p>
        
        <p>
            <b>Notes:</b> In this circuit there are actually two adders given that there is
            also an adder embedded in the Negate module. We could refine the design and share a single Adder for both purposes, but this solution
            is slightly more convenient and allows us to implement the subtraction operation easily. The negation performed on the selector of Mux5
            is somewhat unecessary. It is present in this schematic just to achieve a more convenient layout of the inputs.
        </p>
        
        <figure>
            <img src="resources/alu.svg" width="600">
            <figcaption>Fig.8 ALU Schematic</figcaption>
        </figure>  

        <p>
            This ALU can be implemented in VHDL as follows:
        </p>

        <pre>
            <code>
    entity ALU is

    Port (
        a : IN STD_LOGIC_VECTOR(8 downto 0);
        b : IN STD_LOGIC_VECTOR(8 downto 0);
        opc : IN STD_LOGIC_VECTOR(2 downto 0);
        
        result : OUT STD_LOGIC_VECTOR(8 downto 0);
        zeroF : OUT STD_LOGIC;
        negativeF : OUT STD_LOGIC;
        overflowF : OUT STD_LOGIC
    );
    end ALU;
    
    architecture Behavioral of ALU is
    
    signal isc, iac, inc, addC, negOF, overf, carry : STD_LOGIC;
    signal opc_2 : STD_LOGIC_VECTOR(1 downto 0);
    signal opc_M5 : STD_LOGIC_VECTOR(2 downto 0);
    signal om4, om2, om5, addR, negA, notA, andAB, orAB : STD_LOGIC_VECTOR(8 downto 0);
    
    // Components code here
    
    begin
    isc <= (not opc(0)) and (not opc(1)) and opc(2)        // Is Sub Code (001)
    iac <= (not opc(0)) and (not opc(1)) and (not opc(2))  // Is Add Code (000)
    inc <= opc(0) and (not opc(1)) and (not opc(2))        // Is Neg Code (100)

    
    opc_2(0) <= opc(0);
    opc_2(1) <= opc(1);
    
    MUX4_M: Mux4 port map (B, negA, "00000001", "11111111", opc_2, om4);
    MUX2_M: Mux2 port map (A, B, isc, om2);
    
    ADDER_M: Adder port map(A, om4, addR, addC);
    NEGATE_M: Negate port map(om2, negA, negOF);
    NOT_M: Not_8 port map(A, notA);
    AND_M: And_8 port map(a, b, andAB);
    OR_M: Or_8 port map(a, b, orAB);
    
    opc_M5(0) <= opc(0);
    opc_M5(1) <= opc(1);
    opc_M5(2) <= not opc(2);
    
    MUx5_M: Mux5 port map (negA, notA, andAB, orAB, addR, opc_M5, om5);
    
    IS_NEGATIVE_M: isNegative port map (om5, negativeF);
    IS_ZERO_M: isZero port map (om5, zeroF);
    
    carry <= addC and iac;
    overf <= negOF and inc;
    overflowF <= carry or overf;
    
    result <= om5;
    end Behavioral;                
            </code>
        </pre>
        
        <h2 id="state">4. State, Memory and Clock</h2>

        <!--
            Flip-Flops
            Register
            Memory
        -->

        <figure style="display: inline-block; margin-right: 20px;">
            <img src="resources/sr_flip_flop.svg" width="300">
            <figcaption>Fig.9 SR Flip-Flop</figcaption>
        </figure>
        
        <figure style="display: inline-block;">
            <table border="1">
                <thead>
                    <tr>
                        <th>S</th>
                        <th>R</th>
                        <th>Qn+1</th>
                    </tr>
                </thead>

                <tbody>
                    <tr>
                        <td>0</td>
                        <td>0</td>
                        <td>Qn</td>
                    </tr>
                    <tr>
                        <td>0</td>
                        <td>1</td>
                        <td>0</td>
                    </tr>
                    <tr>
                        <td>1</td>
                        <td>0</td>
                        <td>1</td>
                    </tr>
                    <tr>
                        <td>1</td>
                        <td>1</td>
                        <td>Indeterminate</td>
                    </tr>
                </tbody>
            </table>
            <figcaption>Tab.2 SR Flip-Flop Truth Table</figcaption>
        </figure>
        

        <p>
            With the ALU built, we can now perform "all" the operations we need. However, we need some way to store the results of these operations and data in general. 
            Fortunately, some smart physicists in the early 20th century found a way to store information using circuits, called multi-vibrators, that can easily be reproduced 
            using transistor-based logic gates. Fig.9 shows the schematic of a SR Flip-Flop. A SR Flip-Flop stores a state Q (Q' is equal to ~Q) and provides two inputs
            to set the state (Q = 1) and reset the state (Q = 0). Considering that the Flip-Flop is in the current state Qn, Tab.2 presents its truth table. Given that the
            NOR gate's output is only 1 when both outputs are 0, we can see that if Q is 1 and Q' is 0, setting S to 1 results in Q chaning to 0 and therefore Q' to 1. While 
            setting R to 0 results in Q' chaging to 1 and therefore Q to 0. If this doesn't seem clear, Ben Eater has a great comprehensive <a href="https://www.youtube.com/watch?v=KM0DdEaY5sY&t=241s">video</a> 
            on this circuit alone.
        </p>

        <figure>
            <img src="resources/clock.jpg" width="400">
            <figcaption>Fig.10 Clock Signal</figcaption>
        </figure>

        <p>
            Given that usually computer programs must perform a sequence of instructions, and not just a single operation, CPUs need a mechanism to sequence these
            instructions. This is where the clock comes in. Inside every computer is a clock generator, usually a crystal oscillator, that generates a pulse (or voltage)
            at even intervals as seen in Fig.10. The CPU can then use this clock to perform an instruction step on each clock cycle (More information on this in chapter 6). This means that
            state changes inside a CPU must also occur synchronously with the clock. Ideally, the state of a Flip-Flop inside a CPU, should only be updated during a clock pulse
            (a change of signal from 0 to 1, or from 1 to 0) to eliminate any glitches related to signal propagation delays.
        </p>

        <figure style="display: inline-block; margin-right: 20px;">
            <img src="resources/d_flip_flop.svg" width="400">
            <figcaption>Fig.11 D Flip-Flop</figcaption>
        </figure>
        
        <figure style="display: inline-block;">
            <table border="1">
                <thead>
                    <tr>
                        <th>D</th>
                        <th>En</th>
                        <th>Qn+1</th>
                    </tr>
                </thead>

                <tbody>
                    <tr>
                        <td>0</td>
                        <td>1</td>
                        <td>0</td>
                    </tr>
                    <tr>
                        <td>1</td>
                        <td>1</td>
                        <td>1</td>
                    </tr>
                    <tr>
                        <td>X</td>
                        <td>0</td>
                        <td>Qn</td>
                    </tr>   
                </tbody>    
            </table>
            <figcaption>Tab.3 D Flip-Flop Truth Table</figcaption>
        </figure>        

        <p>
            Fig.11 shows the schematic for a D Flip-Flop. This Flip-Flop is similar to the
            previous one, but receives an enable signal as input, which can be connected to the clock signal (or connected to an AND gate with the clock signal) to ensure that any state changes issued to the Flip-Flop 
            are only triggered during a clock pulse*. It also combines the previous S and R inputs into
            a single Data input. Tab.3 presents the D Enable Flip-Flop's truth table. 
            <!-- Considering the enable input is connected to an AND gate with a clock signal, it can be used as follows: 
            the Flip-Flop initially stores some state and is disabled. Whenever we want to update its state,
            we enable it and feed it the new data/state we want it to store. Then during the clock pulse* the update is triggered, and finally we disable it again.
         -->
        </p>

        <p>
            Note the asteriscs I added when mentioning the clock pulse in the previous paragraph. This circuit does not in fact trigger the update during a clock pulse, but rather, allows updates
            whenever the clock is set to 1. We can refine the Flip-Flop to only trigger during a clock pulse by utilizing a master-slave Flip-Flop system. We won't get into details
            on how a master-slave Flip-Flop works, but it basically involves chaining two Flip-Flops and using the first's input as the second's enable input. Ben Eater has a great 
            <a href="https://www.youtube.com/watch?v=rXHSB5w7CyE&t=380s">video</a>
            going through a master-slave JK Flip-Flop if you're interested (and also a <a href="https://www.youtube.com/watch?v=F1OC5e7Tn_o">video</a> on JK Flip-Flops).
            Given that implementing one of these Flip-Flops manually (using logic) in VHDL can be prone to latching bugs, we will make an exception, and implement the D 
            Flip-Flop using a VHDL process. This Flip-Flop includes a reset input which just sets the input to zero, and an enable input which sets Q to the
            input data D whenever there is a pulse from 0 to 1:
        </p>

        <pre>
            <code>
    entity DFlipFlop is

    Port(
        D, En, R : in STD_LOGIC;
        Q : OUT STD_LOGIC
    );
    
    end DFlipFlop;
    
    architecture Behavioral of DFlipFlop is
    
    begin
    
        process (D, En, R) begin
            if(R = '1') then
            Q <= '0';
            elsif (En'event and En = '1') then
            Q <= D;
            end if;
        end process; 
    
    end Behavioral;
            </code>
        </pre>

        <p>
            With a D Flip-Flop, implementing an 8-bit register is trivial. We simply use a D Flip-Flop per bit to store the 8-bit value.
            We can implement an 8-bit register in VHDL as follows:
        </p>

        <pre>
            <code>
    entity Register_8b is
    Port(
        En, R : in STD_LOGIC;
        DIn : in STD_LOGIC_VECTOR(7 downto 0);
        DOut : out STD_LOGIC_VECTOR(7 downto 0)
    );
    end Register_8b;
    
    architecture Behavioral of Register_8b is
    // Components code here
    begin
        DFF_0: DFlipFlop port map (DIn(0), En, R, DOut(0));
        DFF_1: DFlipFlop port map (DIn(1), En, R, DOut(1));
        DFF_2: DFlipFlop port map (DIn(2), En, R, DOut(2));
        DFF_3: DFlipFlop port map (DIn(3), En, R, DOut(3));
        DFF_4: DFlipFlop port map (DIn(4), En, R, DOut(4));
        DFF_5: DFlipFlop port map (DIn(5), En, R, DOut(5));
        DFF_6: DFlipFlop port map (DIn(6), En, R, DOut(6));
        DFF_7: DFlipFlop port map (DIn(7), En, R, DOut(7));
    end Behavioral;
            </code>
        </pre>

        <p>
            A memory module can be implemented as a large array of registers. In a memory module, each register must be accessible by an address.
            The first register can be set to address 0b00000000, the second register to address 0b00000001 and so on. This addressing system can be
            achieved by connecting the registers to a large demultiplexer. A demultiplexer implements the inverse operation of a multiplexer. With a
            slector (the address), the demultiplexer routs an input value to one of the N outputs (N registers for example). Note that there are more efficient 
            (using less logic gates) of implementing a memory module. Since the focus of this project is the implementation of a CPU, and not necessarily memory
            modules, I implemented the 
            <a href="https://github.com/dma-neves/dcpu/blob/main/src/Memory/RAM64.vhd">RAM</a> and 
            <a href="https://github.com/dma-neves/dcpu/blob/main/src/Memory/ROM.vhd">ROM</a> 
            modules using VHDL processes.
        </p>
        
        <h2 id="isa">5. Instruction Set Architecture </h2>

        <!--
            Turing completeness and basic type of instructions for a CPU.
            Need for stack support
            Componentes: registers, memory, ALU, CU 
            why we need seperate registers for accumulators
            why we need address register
            ISA
        -->

        <figure>
            <img src="resources/cpu.png" width="600">
            <figcaption>Fig.12 CPU schematic</figcaption>
        </figure>        

        <p>
            Now that we are able to perform operations and store and manipulate state, its time to define our CPU's architecture as well as its
            ISA (Instruction Set Architecture). A CPU's ISA, is simply the set of instructions it supports. As we discussed in chapter 1, following
            the Von Neumann architecture, our CPU should include a CPU, a memory module, a set of registers and a control unit. Fig.12 shows the
            schematic of the CPU we aim to build. It contains a control unit, two memory modules (a ROM to store a program and a RAM to store data),
            the ALU we implemented previously, a set of registers, and a set of multiplexers and <a href="https://www.electronics-tutorials.ws/combination/comb_3.html">demultiplexers</a> (inverse multiplexer).
            
            In terms of registers, the CPU will have 8 general purpose registers (RA, RB, ..., RH), used to store temporary values during a program's execution, and 7
            specialized registers:

            <ul>
                <li><b>IC:</b> Instruction Counter saves the address of the current instruction being executed.</li>
                <li><b>IR:</b> Instruction Restister saves the instruction (the opcode) being executed.</li>
                <li><b>IDR:</b>Instruction Data Register saves the data associated to the instruction being executed (more on this on chapter 6).</li>
                <li><b>ADR:</b>Address Register saves an address that can be used to address the memory modules or to jump to the specified address/instruction.</li>
                <li><b>IACR:</b>Instruction Accumulator Register saves the result of the ALU from an operation triggered by the instruction being executed.</li>
                <li><b>PACR:</b>Program Accumulator Register saves the result of the ALU during a program counter increment (more on this on chapter 6).</li>
                <li><b>FLAGR:</b>Flag Register saves the values of the flag values from the ALU.</li>
            </ul>
        </p>

        <p>
            With this architecture in mind, we can now define an ISA. For our CPU to be usable it needs to be at the very least Turing complete.
            Turing completeness refers to a system's ability to perform any computation that a <a href="https://en.wikipedia.org/wiki/Turing_machine">Turing machine</a>,
            allowing it to perform virtually any computation. In practice this requires our ISA to support conditional branches, some iteration mechanism and memory
            manipulation. We can achieve this by combining our ALU operations with some load and move operations to move data between registers and memory, a jump 
            operation (jump to a specific instruction or address) and some conditional jump operations. 
        </p>
            
        <p>
            Additionally, as programs get more complex, having a stack becomes
            pretty essential, and for this reason, we will also include some basic support for a stack. Register RH will be used as the stack pointer, and we'll include
            an operation to subtract a value directly from it (useful when addressing variables stored in the stack). 
            
        </p>
            
        <p>
            Finally, some instructions require some data to
            be specified alongside the instruction. For example to subtract a value from the stack pointer, we need to pass a value alongside the instruction.
            We could reserve some of the instruction bits for data, but for convenience we will pass this data seperately.
            This is not very efficient, since in the ROM module (that stores the program), instead of storing each instruction in a single address line, we will require 2
            address lines, one for the instruction and one for the instruction data. We could improve this, but for the sake of simplicitly we will trade some memory efficiency for
            a simpler design. The ISA we will use for our CPU is the following (considering an 8-bit architecture):
        </p>

        <figure>
            <table>
                <thead>
                    <tr>
                        <th>#</th>
                        <th>code</th>
                        <th>instruction</th>
                        <th>data</th>
                        <th>description</th>
                    </tr>
                </thead>

                <tbody>
        
                    <tr>
                        <td>0</td>
                        <td>0b00000000</td>
                        <td>add RX RY</td>
                        <td style="white-space: nowrap;">X | (Y >> 0x4)</td>
                        <td>Adds the values in registers RX and RY</td>
                    </tr>
                    <tr>
                        <td>1</td>
                        <td>0b00000001</td>
                        <td>sub RX RY</td>
                        <td>X | (Y >> 0x4)</td>
                        <td>Subtracts the value in register RY from RX</td>
                    </tr>
                    <tr>
                        <td>2</td>
                        <td>0b00000010</td>
                        <td>ssp $V</td>
                        <td>V</td>
                        <td>Subtract V from the stack pointer</td>
                    </tr>
                    <tr>
                        <td>3</td>
                        <td>0b00000011</td>
                        <td>inc RX</td>
                        <td>X</td>
                        <td>Increments the value in register RX by 1</td>
                    </tr>
                    <tr>
                        <td>4</td>
                        <td>0b00000100</td>
                        <td>dec RX</td>
                        <td>X</td>
                        <td>Decrements the value in register RX by 1</td>
                    </tr>
                    <tr>
                        <td>5</td>
                        <td>0b00000101</td>
                        <td>neg RX</td>
                        <td>X</td>
                        <td>Negates (complements) the value in register RX</td>
                    </tr>
                    <tr>
                        <td>6</td>
                        <td>0b00000110</td>
                        <td>not RX</td>
                        <td>X</td>
                        <td>Performs bitwise NOT operation on the value in register RX</td>
                    </tr>
                    <tr>
                        <td>7</td>
                        <td>0b00000111</td>
                        <td>and RX RY</td>
                        <td>X | (Y >> 0x4)</td>
                        <td>Performs bitwise AND operation between values in registers RX and RY</td>
                    </tr>
                    <tr>
                        <td>8</td>
                        <td>0b00001000</td>
                        <td>or RX RY</td>
                        <td>X | (Y >> 0x4)</td>
                        <td>Performs bitwise OR operation between values in registers RX and RY</td>
                    </tr>
                    <tr>
                        <td>9</td>
                        <td>0b00001001</td>
                        <td>lod $V ADR</td>
                        <td>V</td>
                        <td>Loads the value V into register ADR</td>
                    </tr>
                    <tr>
                        <td>10</td>
                        <td>0b00001010</td>
                        <td>str $V [ADR]</td>
                        <td>V</td>
                        <td>Stores the value V to the memory address [ADR]</td>
                    </tr>
                    <tr>
                        <td>11</td>
                        <td>0b00001011</td>
                        <td>ld [ADR] RX</td>
                        <td>X</td>
                        <td>Loads the value at memory address [ADR] into register RX</td>
                    </tr>
                    <tr>
                        <td>12</td>
                        <td>0b00001100</td>
                        <td>str RX [ADR]</td>
                        <td>X</td>
                        <td>Stores the value in register RX to the memory address [ADR]</td>
                    </tr>
                    <tr>
                        <td>13</td>
                        <td>0b00001101</td>
                        <td>lod RX ADR</td>
                        <td>X</td>
                        <td>Loads the value in register RX to the register ADR</td>
                    </tr>
                    <tr>
                        <td>14</td>
                        <td>0b00001110</td>
                        <td>lod ACR RX</td>
                        <td>X</td>
                        <td>Load the value in the accumulator ACR to the register RX</td>
                    </tr>
                    <tr>
                        <td>15</td>
                        <td>0b00001111</td>
                        <td>lod ACR ADR</td>
                        <td></td>
                        <td>Load the value in the accumulator ACR to the register ADR</td>
                    </tr>
                    <tr>
                        <td>16</td>
                        <td>0b00010000</td>
                        <td>str ACR [ADR]</td>
                        <td></td>
                        <td>Stores the value in the accumulator ACR to the memory address [ADR]</td>
                    </tr>
                    <tr>
                        <td>17</td>
                        <td>0b00010001</td>
                        <td>str IC [ADR]</td>
                        <td></td>
                        <td>Stores the value of the IC to the memory address [ADR]</td>
                    </tr>
                    <tr>
                        <td>18</td>
                        <td>0b00010010</td>
                        <td>jmp ADR</td>
                        <td></td>
                        <td>Unconditionally jumps to the memory address ADR</td>
                    </tr>
                    <tr>
                        <td>19</td>
                        <td>0b00010011</td>
                        <td>jmp A</td>
                        <td>A</td>
                        <td>Unconditionally jumps to address A</td>
                    </tr>
                    <tr>
                        <td>20</td>
                        <td>0b00010100</td>
                        <td>jmpz A</td>
                        <td>A</td>
                        <td>Jumps to the address A if the zero flag is set</td>
                    </tr>
                    <tr>
                        <td>21</td>
                        <td>0b00010101</td>
                        <td>jmpn A</td>
                        <td>A</td>
                        <td>Jumps to the address A if the negative flag is set</td>
                    </tr>
                    <tr>
                        <td>22</td>
                        <td>0b00010110</td>
                        <td>jmpo A</td>
                        <td>A</td>
                        <td>Jumps to the address A if the overflow flag is set</td>
                    </tr>
                    <tr>
                        <td>23</td>
                        <td>0b00010111</td>
                        <td>hlt</td>
                        <td></td>
                        <td>Halts the execution of the program</td>
                    </tr>
                </table>
            </tbody>
            <figcaption>Tab.4 Instruction Set Architecture</figcaption>
        </figure>

        <h2 id="cu">6. Control Unit</h2>

        <!--
            Clock
            State machine (fetch, decode, execute)
            ...
            vhdl code
        -->
        <figure>
            <img src="resources/CU.png" width="550">
            <figcaption>Fig.13 Control Unit</figcaption>
        </figure>

        <p>
            The last piece of the puzzle is the Control Unit which orchestrates all the other components of the CPU. It takes
            a clock signal as input and performs an instruction step on each clock cycle. An instruction can usually be split into three
            logical steps: fetch (get the instruction from memory), decode (decode the instruction) and execute (trigger the inputs of the
            other components of the CPU). In our CPU, each instruction will be composed of 7 steps:

            <ol>
                <li><b>Fetch instruction:</b> Fetch the instruction stored in the memory address [IC] in the ROM module.</li>
                <li><b>Increment IC:</b> Increment the value stored in the register IC using the ALU.</li>
                <li><b>Load increment:</b> Load the value of the previous increment, that is stored int the IACR register, to the IC register.</li>
                <li><b>Fetch instruction data:</b> Fetch the instruction data stored in the memory address [IC] in the ROM module.</li>
                <li><b>Decode and execute:</b> Decode the instruction and execute it by triggering the inputs of the required components.</li>
                <li><b>Increment IC:</b> Same as 2.</li>
                <li><b>Load increment:</b> Same as 3.</li>
            </ol>


            <figure>
                <img src="resources/seven_state_sm.png" width="550">
                <figcaption>Fig.14 Seven-State State Machine</figcaption>
            </figure>

            To perform these steps, the control unit needs a seven-state state machine that loops indefinitely (until the hlt instruction is executed). 
            A state machine can easily implemented using D Flip-Flops. In this case using 7 D Flip-Flops, and 1 D Flip-Flop that resets to 1 instead of 0.
            Fig.14 shows the schematic for this state machine. Initially the state machine is reset, which results in all Flip-Flops to be set to 0
            except the yellow one which is reset to 1. In the next clock cycle the yellow Flip-Flop is set to 0 given its input data is 0. The first
            green Flip-Flop is set to 1 given that the previous state of the yellow Flip-Flop, which is connected to the green Flip-Flop's input data, was 1.
            In the second clock cycle, the second green Flip-Flop's state changes to 1 and the first goes back to 0, this cycle continues until the
            seventh state, at which point its output loops back to the first green Flip-Flop's input data. We can implement this circuit in VHDL as follows:
        </p>

        <pre>
            <code>
    entity SevenState_sm is
    Port(
        clk : in STD_LOGIC;
        reset : in STD_LOGIC;
        
        S0, S1, S2, S3, S4, S5, S6 : out STD_LOGIC
    );
    end SevenState_sm;
    
    architecture Behavioral of SevenState_sm is
    
    // Components code here
    
    signal
    DFFS_D, DFFS_Q,
    DFF0_D, DFF0_Q,
    DFF1_D, DFF1_Q,
    DFF2_D, DFF2_Q,
    DFF3_D, DFF3_Q,
    DFF4_D, DFF4_Q,
    DFF5_D, DFF5_Q,
    DFF6_D, DFF6_Q : STD_LOGIC;
    
    begin
    DFFS_D <= '0';
    DFF0_D <= DFF6_Q or DFFS_Q;
    DFF1_D <= DFF0_Q;
    DFF2_D <= DFF1_Q;
    DFF3_D <= DFF2_Q;
    DFF4_D <= DFF3_Q;
    DFF5_D <= DFF4_Q;
    DFF6_D <= DFF5_Q;
    
    DFFS: DFlipFlopRA port map (DFFS_D, clk, reset, DFFS_Q);
    DFF0: DFlipFlop port map (DFF0_D, clk, reset, DFF0_Q);
    DFF1: DFlipFlop port map (DFF1_D, clk, reset, DFF1_Q);
    DFF2: DFlipFlop port map (DFF2_D, clk, reset, DFF2_Q);
    DFF3: DFlipFlop port map (DFF3_D, clk, reset, DFF3_Q);
    DFF4: DFlipFlop port map (DFF4_D, clk, reset, DFF4_Q);
    DFF5: DFlipFlop port map (DFF5_D, clk, reset, DFF5_Q);
    DFF6: DFlipFlop port map (DFF6_D, clk, reset, DFF6_Q);
    
    S0 <= DFF0_Q;
    S1 <= DFF1_Q;
    S2 <= DFF2_Q;
    S3 <= DFF3_Q;
    S4 <= DFF4_Q;
    S5 <= DFF5_Q;
    S6 <= DFF6_Q;
    end Behavioral;
            </code>
        </pre>

        <p>
            With the state machine built, we can now build our control unit to operate based on the output of the state machine's state.
            Fig.13 shows the control unit we'll build. As you can see it is composed of four main components: 
            <ul>
                <li>
                    The state machine we just built to differentiate each instruction step.
                </li>
                <li>
                    The instruction decoder which is just a demultiplexer using the opcode as the input selector and
                    outputting a bit per instruction (the bit corresponding to the decoded instruction is set to 1 and the rest to 0).
                </li>
                <li>
                    The operation decoder which
                    receives as input the decoded instruction and relevant flags, and outputs the operations that need to be preformed on the CPU like enabling a register, selecting
                    a specific input from a multiplexer, selecting a specific output from a demultiplexer, enable writes to the RAM module, or selecting a operation
                    to perform on the ALU.
                </li>
                <li>
                    Finally, the select and synchronize operations isn't actually a component, but rather a logical aggregation of operations that are performed
                    directly in the control unit module. This "module" triggers the necessary operations for all the instruction steps that aren't the decode and
                    execute step. When the state machine is in the decode and execute step, the operations outputted by the operation decoder are triggered. Also, all the
                    register enable operations are ANDed to the clock signal, as described in chapter 4, to ensure the state of the registers is only updated during
                    clock pulses. 
                </li>
            </ul>
        </p>

        <p>
            As already stated the instruction decoder is just a glorified demultiplexer so we'll skip its VHDL implementation. We'll now go through the
            implementation of the operation decoder. The module has as output, all the possible operations that can be performed on the various components
            of the CPU, this is, all of the inputs of these components. We therefore need to first figure out, which operations (or component inputs) we
            want to trigger in each CPU instruction. Lets start with the first instruction: <code>add RX RY</code>. In order to perform this instruction
            we need to set the ALU's first operand to RX and the second operand to RY, set the ALU's opcode to the <code>add</code> operation and finally,
            enable the accumulator register (PACR). We can achieve this by triggering the following operations:
            <ul>
                <li>Set the ALU's operand A selector to 0b0.</li>
                <li>Set the ALU's operand B selector to 0b0.</li>
                <li>Set the ALU's opcode to 0b000.</li>
                <li>Set the PACR enable to 1.</li>
            </ul>

            Or in terms of setting inputs to 1, we simply need to set PACR_En to 1. The idea is that we now do this for each instruction. This is of course quite time consuming,
            but thankfully, I've already done this boring job in the past, and the complete list of the required operations for each instruction can be found 
            <a href="https://github.com/dma-neves/dcpu/blob/main/other/instruction_outputs/instructionOutputs.txt">here</a>.
        </p>

        <p>
            After knowing all the relationships between each instruction, and the low-level operations that need to be triggered to preform the instruction, we can
            implement the operation decoder module by defining each operation/output as the OR between all the instructions that require that operation/output to be set to 1. 
            
            Note that some instructions also take into account flags to trigger (or not) certain operations, like for example the instruction <code>jmpz</code>, which
            is only performed if the zero flag is set.
        </p>

        
        <p>
            To make our lives easier, I developed a small 
            <a href="https://github.com/dma-neves/dcpu/blob/main/other/instruction_outputs/instOutputsToVHDL.py">python script </a>
            that takes as input the 
            <a href="https://github.com/dma-neves/dcpu/blob/main/other/instruction_outputs/instructionOutputs.txt">list</a> we saw previously,
            and outputs the body of the corresponding module. 

        </p>

        <p>
            Although this script handles most of the modules body, we still have to take into account some important details that will be programmed manually.

            Namely, many of our instructions operate over general purpose registers RX and RY. The indices X and Y are both passed in the instruction data.
            Index X is stored in the first 4 bits (or 8 bits in case of a 16 bit architecture) of the instruction data and index Y in the last 4 bits (or 8 bits).
            The 8 registers are aggregated into a single block like we can see in Fig.12. We use a demultiplexer when we want to update the state of a specific register, 
            and two multiplexer to route the value of specific registers to the rest of the CPU. The first operation (update the state of a register) is always performed
            on index X (load instructions are always performed over RX). This means that the selector of the multiplexer is simply directly wired to the first 4 bits of 
            the IDR (Instruction Data Register).
            For the second operation (routing the output of a register to the rest of the CPU) we need to consider routing both the RX and RY registers to deal
            with instructions that operate over two operands, like <code>add RX RY</code>. This means that the selector of the multiplexer on the left is wired to the
            first 4 bits of the IDR, and the multiplexer on the right is wired to the last 4 bits of the IDR.
        </p>

        <p>
            Finally, also note that the flag register enable can be wired to the same signal as the PACR register enable, given that
            whenever we store the the ALU's result in the PACR register we also of course want to update the flag register. 
        </p>

        <p>
            The final VHDL module code for this operation decoder is the following:
        </p>

        <pre>
            <code>
    entity OpDecoder is
    Port(
        
        En : in STD_LOGIC;
        ZF, NF, OVF : in STD_LOGIC;
        IDR_l, IDR_h : STD_LOGIC_VECTOR(7 downto 0);
    
        add_RX_RY,
        sub_RX_RY,
        ssp_V,
        inc_RX,
        dec_RX,
        neg_RX,
        not_RX,
        and_RX_RY,
        or_RX_RY,
        lod_V_ADR,
        str_V_mADR,
        lod_mADR_RX,
        str_RX_mADR,
        lod_RX_ADR,
        lod_ACR_RX,
        lod_ACR_ADR,
        str_ACR_mADR,
        str_IC_mADR,
        jmp_ADR,
        jmp_X,
        jmpz_X,
        jmpn_X,
        jmpo_X,
        hlt : in STD_LOGIC;
    
        opc : OUT STD_LOGIC_VECTOR(2 downto 0);
        RM_S : OUT STD_LOGIC;
        RXM_S : OUT STD_LOGIC_VECTOR(2 downto 0);
        RYM_S : OUT STD_LOGIC_VECTOR(2 downto 0);
        ICM_S : OUT STD_LOGIC_VECTOR(1 downto 0);
        AM_S : OUT STD_LOGIC_VECTOR(1 downto 0);
        AXM_S : OUT STD_LOGIC;
        AYM_S : OUT STD_LOGIC;
        DOM_S : OUT STD_LOGIC_VECTOR(1 downto 0);
        AOM_S : OUT STD_LOGIC;
        RED_S : OUT STD_LOGIC_VECTOR(2 downto 0);
        IC_En,
        IR_En,
        IDR_En,
        ADR_En,
        ACR_En,
        GPR_En : OUT STD_LOGIC;
        rw : OUT STD_LOGIC
    );
    end OpDecoder;
    
    architecture Behavioral of OpDecoder is
    // Components code here
    signal RXM_S_8b : STD_LOGIC_VECTOR(7 downto 0);
    begin
    
        ACR_En <= En and (add_RX_RY or sub_RX_RY or ssp_V or inc_RX or dec_RX or neg_RX or not_RX or and_RX_RY or or_RX_RY);
        opc(0) <= En and (sub_RX_RY or ssp_V or dec_RX or not_RX or or_RX_RY);
        AYM_S <= En and (ssp_V);
        opc(1) <= En and (inc_RX or dec_RX or and_RX_RY or or_RX_RY);
        opc(2) <= En and (neg_RX or not_RX or and_RX_RY or or_RX_RY);
        AM_S(1) <= En and (lod_V_ADR);
        ADR_En <= En and (lod_V_ADR or lod_RX_ADR or lod_ACR_ADR);
        DOM_S(0) <= En and (str_V_mADR or str_IC_mADR);
        DOM_S(1) <= En and (str_V_mADR or str_ACR_mADR);
        AOM_S <= En and (str_V_mADR or lod_mADR_RX or str_RX_mADR or str_ACR_mADR or str_IC_mADR);
        rw <= En and (str_V_mADR or str_RX_mADR or str_ACR_mADR or str_IC_mADR);
        RM_S <= En and (lod_mADR_RX);
        GPR_En <= En and (lod_mADR_RX or lod_ACR_RX);
        AM_S(0) <= En and (lod_ACR_ADR);
        ICM_S(1) <= En and (jmp_ADR);
        IC_En <= En and (jmp_ADR or jmp_X or (jmpz_X and ZF) or (jmpn_X and NF) or (jmpo_X and OVF));
        ICM_S(0) <= En and (jmp_X or (jmpz_X and ZF) or (jmpn_X and NF) or (jmpo_X and OVF));	
        
        RXM_S <= RXM_S_8b(2 downto 0);
        RYM_S <= IDR_h(2 downto 0);
        RED_S <= IDR_l(2 downto 0);
    
    
        RX_MUX: Mux2_8b port map (
            I0 => IDR_l,
            I1 => "00000111",
            sel => ssp_V,
            o => RXM_S_8b
        );
    
        AXM_S <= '0';
        IDR_En <= '0';
        IR_En <= '0';
    end Behavioral;                
            </code>
        </pre>

        <p>
            As we discussed previously, the select and synchronize operations "module" is just a logical aggregation of operations that are performed
            directly in the control unit module. Given that some of the instruction steps like Increment IC and Load Increment also need to trigger operations
            like the instructions during the Decode and Execute step, a bunch of OR and AND gates are used to select the necessary operations depending on the
            current state of the state-machine and the operations selected by the operation decoder. All the enable operations are also ANDed to the clock signal
            as already stated.
        </p>


        <figure>
            <img src="resources/clock_state_changes.svg" width="350">
            <figcaption>Fig.15 Clock signal and state changes</figcaption>
        </figure>

        <p>
            One important detail is that the register enable operations are actually ANDed to the inverted clock signal (clock signal followed by a NOT gate) instead of the raw clock signal. 
            This results in the registers being updated on the down pulses (clock change from 1 to 0). Fig.15 shows why this is important. The state-machine state changes are triggered 
            during the up clock pulses (clock change from 0 to 1), meaning that the instruction decoding and operation selection, for a given instruction step, starts right after such a pulse.
            If we were to update the registers during the up clock pulses as well, we would get signal propagation delay related glitches. We would update the registers before the correct input
            data would reach the registers. To ensure this doesn't happen, the registers are updated on the down clock pulses, right at the middle point of a clock cycle.    
        </p>

        <p>
            The VHDL code for the control unit is quite long, so I won't include it in this document, but it can be found <a href="https://github.com/dma-neves/dcpu/blob/main/src/CU/ControlUnit.vhd">here</a>.
        </p>

        <p>
            Finally, with the control unit built, the full CPU module can easily be implemented by wiring all the components we have just built as seen in Fig.12.
            Since the code for the module is quite extensive and not particularly intersting, I won't include it in this document, but it can be found
            <a href="https://github.com/dma-neves/dcpu/blob/main/src/Main/CPU.vhd">here</a>,
            and this is what the entity's port looks like:
        </p>

        <pre>
            <code>
    entity CPU is
    Port(
        reset : in STD_LOGIC;
        clk : in STD_LOGIC;
        dataIn : in STD_LOGIC_VECTOR(7 downto 0);
    
        address : out STD_LOGIC_VECTOR(7 downto 0);
        dataOut : out STD_LOGIC_VECTOR(7 downto 0);
        readWrite : out STD_LOGIC;
        fetch : out STD_LOGIC; 
    );
    end CPU;
            </code>
        </pre>

        <p>
            Similarly, the main module also just involves wiring the CPU module with the memory modules.

            To switch between the RAM and ROM modules, a the fetch signal (controlled by the control unit) is used to enable and disable the two memory modules. Whenever fetch is set to 1, to ROM
            module is enabled and the RAM disabled, and vice-versa. The fetch signal is only set to zero during the Decode and Execute step.
        </p>

        <h2 id="firstprogram">7. Executing a Program</h2>

        <h2 id="assebler">8. Assembler</h2>

        <h2 id="fpga">9. FPGA</h2>

        <figure>
            <img src="resources/fpga.jpg" width="450">
            <figcaption>Fig.# FPGA board</figcaption>
        </figure>

    </div>


</body>

</html>
